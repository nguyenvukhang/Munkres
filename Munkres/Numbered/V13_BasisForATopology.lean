import Munkres.Mathlib.Prelude

open Set TopologicalSpace

universe u

variable {Î± : Type u} {B : Set (Set Î±)}

section DefiningABasis

-- The reason why we reduce all finite intersection arguments to just the
-- intersection of two elements â€” that we can extend it to finite intersections
-- by induction.
example {B : Set (Set Î±)}
  (h : âˆ€ bâ‚ âˆˆ B, âˆ€ bâ‚‚ âˆˆ B, bâ‚ âˆ© bâ‚‚ âˆˆ B)
  (h_univ : univ âˆˆ B)
  : âˆ€ s âŠ† B, s.Finite â†’ â‹‚â‚€ s âˆˆ B
  := by --
  intro s hsB hsF
  induction s, hsF using Set.Finite.induction_on with
  | empty =>
    rw [sInter_empty]
    exact h_univ
  | @insert u s hus hsF ih =>
    have huB : u âˆˆ B := hsB <| mem_insert u s
    if hsâ‚€ : s = âˆ… then
      subst hsâ‚€
      simp only [insert_empty_eq, sInter_singleton]
      exact huB
    else
    replace hsâ‚€ : s.Nonempty := nonempty_iff_ne_empty.mpr hsâ‚€
    specialize ih ((subset_insert u s).trans hsB)
    rw [sInter_insert u s]
    exact h u huB _ ih -- âˆ

variable
  (hâ‚ : âˆ€ x, âˆƒ b âˆˆ B, x âˆˆ b)
  (hâ‚‚ : âˆ€ bâ‚ âˆˆ B, âˆ€ bâ‚‚ âˆˆ B, âˆ€ x âˆˆ bâ‚ âˆ© bâ‚‚, âˆƒ b âˆˆ B, x âˆˆ b âˆ§ b âŠ† bâ‚ âˆ© bâ‚‚)

private lemma lâ‚€ {U : Set Î±} :
  (âˆ€ x âˆˆ U, âˆƒ b âˆˆ B, x âˆˆ b âˆ§ b âŠ† U) â†’ âˆƒ s âŠ† B, U = â‹ƒâ‚€ s
  := by --
  intro h
  let hp (x : U) : Set Î± := (h x x.prop).choose
  let s := Set.range hp
  use Set.range hp
  refine âŸ¨?_, ?_âŸ©
  Â· intro _ âŸ¨x, heqâŸ©
    subst heq
    exact (h x x.prop).choose_spec.1
  Â· rw [Set.sUnion_range]
    ext x : 1
    rw [Set.mem_iUnion]
    refine âŸ¨?_, ?_âŸ©
    Â· intro hx
      exact âŸ¨âŸ¨x, hxâŸ©, (h x hx).choose_spec.2.1âŸ©
    Â· intro âŸ¨y, hyâŸ©
      exact (h y y.prop).choose_spec.2.2 hy -- âˆ

include hâ‚ hâ‚‚ in
private lemma lâ‚
  : âˆ€ U, @IsOpen Î± (generateFrom B) U â†’ âˆ€ x âˆˆ U, âˆƒ b âˆˆ B, x âˆˆ b âˆ§ b âŠ† U
  := by --
  intro U h x hx
  induction h with
  | basic b hb =>
    exact âŸ¨b, hb, hx, le_rflâŸ©
  | univ =>
    obtain âŸ¨b, hâŸ© := hâ‚ x
    exact âŸ¨b, h.1, h.2, Set.subset_univ _âŸ©
  | inter uâ‚ uâ‚‚ _ _ huâ‚ huâ‚‚ =>
    obtain âŸ¨bâ‚, hbâ‚, hxâ‚, huâ‚âŸ© := huâ‚ hx.1
    obtain âŸ¨bâ‚‚, hbâ‚‚, hxâ‚‚, huâ‚‚âŸ© := huâ‚‚ hx.2
    specialize hâ‚‚ bâ‚ hbâ‚ bâ‚‚ hbâ‚‚ x âŸ¨hxâ‚, hxâ‚‚âŸ©
    obtain âŸ¨b, hbB, hxb, hbâŸ© := hâ‚‚
    refine âŸ¨b, hbB, hxb, ?_âŸ©
    rw [Set.subset_inter_iff] at hb âŠ¢
    exact âŸ¨hb.1.trans huâ‚, hb.2.trans huâ‚‚âŸ©
  | sUnion s _ hs =>
    obtain âŸ¨u, hus, hxuâŸ© := hx
    specialize hs u hus hxu
    obtain âŸ¨b, hbB, hxb, hbuâŸ© := hs
    refine âŸ¨b, hbB, hxb, ?_âŸ©
    refine hbu.trans ?_
    exact Set.subset_sUnion_of_subset s u le_rfl hus -- âˆ

private lemma lâ‚‚
  : âˆ€ U, (âˆ€ x âˆˆ U, âˆƒ b âˆˆ B, x âˆˆ b âˆ§ b âŠ† U) â†’ @IsOpen Î± (generateFrom B) U
  := by --
  intro U h
  obtain âŸ¨s, hs, heqâŸ© := lâ‚€ h
  subst heq
  refine GenerateOpen.sUnion s ?_
  intro u hu
  refine GenerateOpen.basic u ?_
  exact hs hu -- âˆ

include hâ‚ hâ‚‚ in
/-- Here's how Munkres defines the topology generated by a basis. In particular,
`T = generateFrom B` -/
private lemma lâ‚ƒ {U : Set Î±}
  : @IsOpen Î± (generateFrom B) U â†” âˆ€ x âˆˆ U, âˆƒ b âˆˆ B, x âˆˆ b âˆ§ b âŠ† U
  := âŸ¨lâ‚ hâ‚ hâ‚‚ U, lâ‚‚ UâŸ©

end DefiningABasis

section Sâ‚
--* Lemma 13.1
variable [TopologicalSpace Î±] (hB : IsTopologicalBasis B)

-- In other words, ğ“£ = collection of all unions of elements of ğ“‘.
example {U : Set Î±} : IsOpen U â†” âˆƒ s âŠ† B, U = â‹ƒâ‚€ s  := by
  refine âŸ¨?_, ?_âŸ©
  Â· intro hU
    rw [hB.isOpen_iff] at hU
    exact lâ‚€ hU
  Â· intro âŸ¨s, hs, heqâŸ©
    subst heq
    refine isOpen_sUnion ?_
    intro u hu
    exact hB.isOpen (hs hu)

end Sâ‚

section Sâ‚‚
--* Lemma 13.2
variable [TopologicalSpace Î±] {C : Set (Set Î±)}
  (hâ‚ : âˆ€ c âˆˆ C, IsOpen c)
  (hâ‚‚ : âˆ€ u, IsOpen u â†’ âˆ€ x âˆˆ u, âˆƒ c âˆˆ C, x âˆˆ c âˆ§ c âŠ† u)

example : IsTopologicalBasis C
  := by --
  have hâ‚ƒ : âˆ€ x, âˆƒ b âˆˆ C, x âˆˆ b := by
    intro x
    obtain âŸ¨c, hcC, hxc, _âŸ© := hâ‚‚ Set.univ isOpen_univ x trivial
    exact âŸ¨c, hcC, hxcâŸ©
  have hâ‚„ : âˆ€ s âˆˆ C, âˆ€ t âˆˆ C, âˆ€ x âˆˆ s âˆ© t, âˆƒ c âˆˆ C, x âˆˆ c âˆ§ c âŠ† s âˆ© t := by
    intro s hs t ht x hx
    exact hâ‚‚ (s âˆ© t) ((hâ‚ s hs).inter (hâ‚ t ht)) x hx
  exact {
    sUnion_eq := Set.sUnion_eq_univ_iff.mpr hâ‚ƒ
    exists_subset_inter := hâ‚„
    eq_generateFrom := by
      refine TopologicalSpace.ext ?_
      ext u : 2
      rw [lâ‚ƒ hâ‚ƒ hâ‚„]
      refine âŸ¨hâ‚‚ u, ?_âŸ©
      intro h
      obtain âŸ¨s, hs, heqâŸ© := lâ‚€ h
      subst heq
      exact isOpen_sUnion fun t ht â†¦ hâ‚ t (hs ht)
  } -- âˆ

end Sâ‚‚

section Sâ‚ƒ
--* Lemma 13.2
variable [T : TopologicalSpace Î±] [T' : TopologicalSpace Î±]
  {B B' : Set (Set Î±)}
  (hB : IsTopologicalBasis (t := T) B)
  (hB' : IsTopologicalBasis (t := T') B')

-- Note that T' is finer than T here.
example : T' â‰¤ T â†” âˆ€ x, âˆ€ b âˆˆ B, x âˆˆ b â†’ âˆƒ b' âˆˆ B', x âˆˆ b' âˆ§ b' âŠ† b
  := by --
  constructor
  Â· intro hle x b hbB hxb
    have hb : @IsOpen Î± T b := hB.isOpen (t := T) hbB
    have hb' : @IsOpen Î± T' b := hle b hb
    rw [hB'.isOpen_iff] at hb'
    exact hb' x hxb
  Â· intro h u hu
    rw [hB.isOpen_iff (t := T)] at hu
    rw [hB'.isOpen_iff]
    intro x hx
    obtain âŸ¨b, hbB, hxb, hbuâŸ© := hu x hx
    obtain âŸ¨b', hbB', hxb', hbbâŸ© := h x b hbB hxb
    exact âŸ¨b', hbB', hxb', hbb.trans hbuâŸ© -- âˆ

end Sâ‚ƒ
